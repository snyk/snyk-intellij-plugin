package io.snyk.plugin.datamodel

import io.circe.derivation.{deriveDecoder, deriveEncoder}
import io.circe.{Decoder, Encoder, JsonObject, ObjectEncoder}
import cats.syntax.functor._
import io.circe.derivation._
import io.circe.syntax._


case class Semver(vulnerable: Seq[String])

case class MavenModuleName(
                            groupId: String,
                            artifactId: String
                          )

sealed trait Vulnerability

case class SecurityVuln(
                         title            : String,
                         credit           : Seq[String],
                         description      : String,
                         moduleName       : String,
                         language         : String,
                         packageManager   : String,
                         semver           : Semver,
                         identifiers      : Map[String, Seq[String]],
                         CVSSv2           : Option[String],
                         severity         : String,
                         creationTime     : String,
                         modificationTime : String,
                         publicationTime  : String,
                         disclosureTime   : String,
                         id               : String,
                         mavenModuleName  : MavenModuleName,
                         CVSSv3           : String,
                         packageName      : String,
                         cvssScore        : Float,
                         from             : Seq[String],
                         upgradePath      : Seq[Either[Boolean, String]],
                         version          : String,
                         name             : String,
                         isUpgradable     : Boolean,
                         isPatchable      : Boolean,
                         filtered         : Option[VulnFilteredInfo]
                       ) extends Vulnerability {
  /**
    * @return A combined string of the Snyk ID and CWE ID (if present)
    */
  def combinedId: String = {
    val cwe = identifiers.get("CWE").flatMap(_.headOption).filterNot(_.isEmpty)
    val cweSuffix = cwe.map(" (" + _ + ")").getOrElse("")
    s"$id$cweSuffix"
  }

  /**
    * @return A sequence of just the String components in the upgrade path, or "n/a"
    */
  def normalisedUpgradePath: Seq[String] =
    if(isUpgradable) { upgradePath.flatMap(_.right.toSeq) } else Seq("n/a")

  def toMiniVuln: MiniVuln = MiniVuln from this
}

case class LicenseVuln(
                        `type`             : String,
                        license            : String,
                        licenseTemplateUrl : Either[String, Array[String]],
                        title              : String,
                        description        : String,
                        language           : String,
                        packageManager     : String,
                        packageName        : String,
                        semver             : Semver,
                        severity           : String,
                        creationTime       : String,
                        publicationTime    : String,
                        id                 : String,
                        from               : Seq[String],
                        upgradePath        : Seq[Either[Boolean, String]],
                        version            : String,
                        name               : String,
                        isUpgradable       : Boolean,
                        isPatchable        : Boolean
                      ) extends Vulnerability

case class IgnoredBy(
                      id    : String,
                      name  : String,
                      email : String
                    )

object IgnoredBy {
  implicit val encoder: ObjectEncoder[IgnoredBy] = deriveEncoder
  implicit val decoder: Decoder[IgnoredBy] = deriveDecoder
}

case class VulnIgnoredInfo(
                            reason             : String,
                            created            : String,
                            expires            : String,
                            ignoredBy          : IgnoredBy,
                            reasonType         : String,
                            disregardIfFixable : Boolean,
                            source             : String,
                            path               : Seq[String]
                          )

object VulnIgnoredInfo {
  implicit val encoder: ObjectEncoder[VulnIgnoredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnIgnoredInfo] = deriveDecoder
}

case class VulnFilteredInfo(ignored: Seq[VulnIgnoredInfo])

object VulnFilteredInfo {
  implicit val encoder: ObjectEncoder[VulnFilteredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnFilteredInfo] = deriveDecoder
}

case class LicensesPolicy(severities: Map[String, String])

case class TopLevelFilteredInfo(
                                 ignore: Seq[Vulnerability],
                                 patch:  Seq[JsonObject]
                               )

case class SnykVulnResponse(
     ok               : Boolean,
     vulnerabilities  : Option[Seq[Vulnerability]],
     dependencyCount  : Option[Int],
     org              : Option[String],
     licensesPolicy   : Option[LicensesPolicy],
     isPrivate        : Option[Boolean],
     packageManager   : Option[String],
     policy           : Option[String],
     ignoreSettings   : Option[Map[String, Boolean]],
     summary          : Option[String],
     filesystemPolicy : Option[Boolean],
     filtered         : Option[TopLevelFilteredInfo],
     uniqueCount      : Option[Int],
     path             : Option[String],
     error            : Option[String]
   ) {
  def ignoredVulnerabilities: Seq[Vulnerability] = filtered.toSeq.flatMap(_.ignore)

  lazy val securityVulns: Seq[SecurityVuln] =
    vulnerabilities match {
      case Some(vulnerabilities) => vulnerabilities collect { case securityVuln: SecurityVuln => securityVuln }
      case None => Seq[SecurityVuln]()
    }

  lazy val ignoredSecurityVulns: Seq[SecurityVuln] =
    ignoredVulnerabilities collect { case sv: SecurityVuln => sv }

  lazy val flatMiniVulns: Seq[MiniVuln] = {
    //    val vulns: Seq[MiniVuln] = (securityVulns.map(MiniVuln.from) ++ ignoredVulnerabilities.map(MiniVuln.from)).distinct
    securityVulns.map(MiniVuln.from).distinct
  }

  lazy val mergedMiniVulns: Seq[MiniVuln] = {
    MiniVuln.merge(flatMiniVulns)
  }

  def isEmpty: Boolean = this eq SnykVulnResponse.empty
}

object SnykVulnResponse {
  val empty: SnykVulnResponse = SnykVulnResponse(
    ok               = true,
    vulnerabilities  = None,
    dependencyCount  = Option(0),
    org              = Option(""),
    licensesPolicy   = None,
    isPrivate        = Option(false),
    packageManager   = Option(""),
    policy           = Option(""),
    ignoreSettings   = None,
    summary          = Option(""),
    filesystemPolicy = None,
    filtered         = None,
    uniqueCount      = None,
    path             = None,
    error            = None
  )

  trait LowPriorityJsonCodecs {
    implicit def encodeEither[A, B](implicit a: Encoder[A], b: Encoder[B]): Encoder[Either[A, B]] = {
      o: Either[A, B] => o.fold(_.asJson, _.asJson)
    }
  }

  object JsonCodecs extends LowPriorityJsonCodecs with io.circe.java8.time.TimeInstances {

    implicit def decodeEither[A,B](implicit a: Decoder[A], b: Decoder[B]): Decoder[Either[A,B]] = {
      val l: Decoder[Either[A,B]] = a.map(Left.apply)
      val r: Decoder[Either[A,B]] = b.map(Right.apply)
      l or r
    }

    implicit def objectEncodeEither[A, B](
                                           implicit
                                           a: ObjectEncoder[A],
                                           b: ObjectEncoder[B]
                                         ): ObjectEncoder[Either[A, B]] = {
      o: Either[A, B] => o.fold(_.asJsonObject, _.asJsonObject)
    }

    // We wse semi-auto derivation from circe-deriving here instead of fully-auto derivation from circe-generic
    // On the down-side, it means that we actually have to write some code, but in exchange it gives us
    // *significantly* faster compilation and we get a smaller plugin by removing remove some transitive deps
    // (including shapeless)
    //
    // If these 10 lines of code (at time of writing) ever *truly* become a problem,
    // we can switch to circe-magnolia-derivation

    implicit val decoderVulnIgnoredBy         : Decoder[IgnoredBy]             = deriveDecoder
    implicit val decoderVulnIgnoredInfo       : Decoder[VulnIgnoredInfo]       = deriveDecoder
    implicit val decoderVulnFilteredInfo      : Decoder[VulnFilteredInfo]      = deriveDecoder
    implicit val decoderLicensesPolicy        : Decoder[LicensesPolicy]        = deriveDecoder
    implicit val decoderMavenModuleName       : Decoder[MavenModuleName]       = deriveDecoder
    implicit val decoderSemver                : Decoder[Semver]                = deriveDecoder

    implicit val decoderSecurityVuln          : Decoder[SecurityVuln]          = deriveDecoder
    implicit val decoderLicenseVuln           : Decoder[LicenseVuln]           = deriveDecoder

    implicit val decoderVulnerability: Decoder[Vulnerability] =
      decoderSecurityVuln.widen or decoderLicenseVuln.widen

    implicit val decoderTopLevelFilteredInfo  : Decoder[TopLevelFilteredInfo]  = deriveDecoder
    implicit val decoderSnykVulnResponse      : Decoder[SnykVulnResponse]      = deriveDecoder

    implicit val encoderVulnIgnoredBy         : ObjectEncoder[IgnoredBy]        = deriveEncoder
    implicit val encoderVulnIgnoredInfo       : ObjectEncoder[VulnIgnoredInfo]  = deriveEncoder
    implicit val encoderVulnFilteredInfo      : ObjectEncoder[VulnFilteredInfo] = deriveEncoder
    implicit val encoderLicensesPolicy        : ObjectEncoder[LicensesPolicy]   = deriveEncoder
    implicit val encoderMavenModuleName       : ObjectEncoder[MavenModuleName]  = deriveEncoder
    implicit val encoderSemver                : ObjectEncoder[Semver]           = deriveEncoder

    implicit val encoderSecurityVuln          : ObjectEncoder[SecurityVuln]     = deriveEncoder
    implicit val encoderLicenseVuln           : ObjectEncoder[LicenseVuln]      = deriveEncoder

    implicit val encoderVulnerability: ObjectEncoder[Vulnerability] = ObjectEncoder.instance {
      case sec: SecurityVuln => sec.asJsonObject
      case lic: LicenseVuln => lic.asJsonObject
    }

    implicit val encoderTopLevelFilteredInfo  : ObjectEncoder[TopLevelFilteredInfo]  = deriveEncoder
    implicit val encoderSnykVulnResponse      : ObjectEncoder[SnykVulnResponse]      = deriveEncoder
  }
}

case class CLIError(ok: Boolean, error: String, path: String)



