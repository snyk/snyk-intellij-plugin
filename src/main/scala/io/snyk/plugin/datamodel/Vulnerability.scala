package io.snyk.plugin.datamodel

import io.circe.derivation.{deriveDecoder, deriveEncoder}
import io.circe.{Decoder, Encoder, JsonObject, ObjectEncoder}
import cats.syntax.functor._
import io.circe.derivation._
import io.circe.syntax._


case class Semver(vulnerable: Seq[String])

case class MavenModuleName(
  groupId: String,
  artifactId: String
)

sealed trait Vulnerability

case class SecurityVuln(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : String,
  modificationTime : String,
  publicationTime  : String,
  disclosureTime   : String,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
  filtered         : Option[VulnFilteredInfo]
) extends Vulnerability {
  /**
    * @return A combined string of the Snyk ID and CWE ID (if present)
    */
  def combinedId: String = {
    val cwe = identifiers.get("CWE").flatMap(_.headOption).filterNot(_.isEmpty)
    val cweSuffix = cwe.map(" (" + _ + ")").getOrElse("")
    s"$id$cweSuffix"
  }

  /**
    * @return A sequence of just the String components in the upgrade path, or "n/a"
    */
  def normalisedUpgradePath: Seq[String] =
    if(isUpgradable) { upgradePath.flatMap(_.right.toSeq) } else Seq("n/a")

  def toMiniVuln: MiniVuln = MiniVuln.from(this, Option.empty, Option.empty)
}

case class LicenseVuln(
  `type`             : String,
  license            : String,
  licenseTemplateUrl : Either[String, Array[String]],
  title              : String,
  description        : String,
  language           : String,
  packageManager     : String,
  packageName        : String,
  semver             : Semver,
  severity           : String,
  creationTime       : String,
  publicationTime    : String,
  id                 : String,
  from               : Seq[String],
  upgradePath        : Seq[Either[Boolean, String]],
  version            : String,
  name               : String,
  isUpgradable       : Boolean,
  isPatchable        : Boolean
) extends Vulnerability

case class IgnoredBy(
  id    : String,
  name  : String,
  email : String
)

object IgnoredBy {
  implicit val encoder: ObjectEncoder[IgnoredBy] = deriveEncoder
  implicit val decoder: Decoder[IgnoredBy] = deriveDecoder
}

case class VulnIgnoredInfo(
  reason             : String,
  created            : String,
  expires            : String,
  ignoredBy          : IgnoredBy,
  reasonType         : String,
  disregardIfFixable : Boolean,
  source             : String,
  path               : Seq[String]
)

object VulnIgnoredInfo {
  implicit val encoder: ObjectEncoder[VulnIgnoredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnIgnoredInfo] = deriveDecoder
}

case class VulnFilteredInfo(ignored: Seq[VulnIgnoredInfo])

object VulnFilteredInfo {
  implicit val encoder: ObjectEncoder[VulnFilteredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnFilteredInfo] = deriveDecoder
}

case class LicensesPolicy(severities: Map[String, String])

case class TopLevelFilteredInfo(
  ignore: Seq[Vulnerability],
  patch:  Seq[JsonObject]
)

case class SnykVulnResponse(
  ok               : Boolean,
  vulnerabilities  : Option[Seq[Vulnerability]],
  dependencyCount  : Option[Int],
  org              : Option[String],
  licensesPolicy   : Option[LicensesPolicy],
  isPrivate        : Option[Boolean],
  packageManager   : Option[String],
  policy           : Option[String],
  ignoreSettings   : Option[Map[String, Boolean]],
  summary          : Option[String],
  filesystemPolicy : Option[Boolean],
  filtered         : Option[TopLevelFilteredInfo],
  uniqueCount      : Option[Int],
  path             : Option[String],
  displayTargetFile: Option[String],
  projectName      : Option[String],
  error            : Option[String]
) {
  def ignoredVulnerabilities: Seq[Vulnerability] = filtered.toSeq.flatMap(_.ignore)

  lazy val securityVulns: Seq[SecurityVuln] =
    vulnerabilities match {
      case Some(vulnerabilities) => vulnerabilities collect { case securityVuln: SecurityVuln => securityVuln }
      case None => Seq[SecurityVuln]()
    }

  lazy val ignoredSecurityVulns: Seq[SecurityVuln] =
    ignoredVulnerabilities collect { case sv: SecurityVuln => sv }

  lazy val flatMiniVulns: Seq[MiniVuln] = {
    securityVulns.map(securityVuln => MiniVuln.from(securityVuln, projectName, displayTargetFile)).distinct
  }

  lazy val mergedMiniVulns: Seq[MiniVuln] = {
    MiniVuln.merge(flatMiniVulns)
  }

  def isEmpty: Boolean = this eq SnykVulnResponse.empty
}

object SnykVulnResponse {
  val empty: SnykVulnResponse = SnykVulnResponse(
    ok               = true,
    vulnerabilities  = None,
    dependencyCount  = Option(0),
    org              = Option(""),
    licensesPolicy   = None,
    isPrivate        = Option(false),
    packageManager   = Option(""),
    policy           = Option(""),
    ignoreSettings   = None,
    summary          = Option(""),
    filesystemPolicy = None,
    filtered         = None,
    uniqueCount      = None,
    path             = None,
    displayTargetFile= None,
    projectName      = None,
    error            = None
  )

  trait LowPriorityJsonCodecs {
    implicit def encodeEither[A, B](implicit a: Encoder[A], b: Encoder[B]): Encoder[Either[A, B]] = {
      o: Either[A, B] => o.fold(_.asJson, _.asJson)
    }
  }

  object JsonCodecs extends LowPriorityJsonCodecs with io.circe.java8.time.TimeInstances {

    implicit def decodeEither[A,B](implicit a: Decoder[A], b: Decoder[B]): Decoder[Either[A,B]] = {
      val l: Decoder[Either[A,B]] = a.map(Left.apply)
      val r: Decoder[Either[A,B]] = b.map(Right.apply)
      l or r
    }

    implicit def objectEncodeEither[A, B](
      implicit
      a: ObjectEncoder[A],
      b: ObjectEncoder[B]
    ): ObjectEncoder[Either[A, B]] = {
      o: Either[A, B] => o.fold(_.asJsonObject, _.asJsonObject)
    }

    // We wse semi-auto derivation from circe-deriving here instead of fully-auto derivation from circe-generic
    // On the down-side, it means that we actually have to write some code, but in exchange it gives us
    // *significantly* faster compilation and we get a smaller plugin by removing remove some transitive deps
    // (including shapeless)
    //
    // If these 10 lines of code (at time of writing) ever *truly* become a problem,
    // we can switch to circe-magnolia-derivation

    implicit val decoderVulnIgnoredBy         : Decoder[IgnoredBy]             = deriveDecoder
    implicit val decoderVulnIgnoredInfo       : Decoder[VulnIgnoredInfo]       = deriveDecoder
    implicit val decoderVulnFilteredInfo      : Decoder[VulnFilteredInfo]      = deriveDecoder
    implicit val decoderLicensesPolicy        : Decoder[LicensesPolicy]        = deriveDecoder
    implicit val decoderMavenModuleName       : Decoder[MavenModuleName]       = deriveDecoder
    implicit val decoderSemver                : Decoder[Semver]                = deriveDecoder

    implicit val decoderSecurityVuln          : Decoder[SecurityVuln]          = deriveDecoder
    implicit val decoderLicenseVuln           : Decoder[LicenseVuln]           = deriveDecoder

    implicit val decoderVulnerability: Decoder[Vulnerability] =
      decoderSecurityVuln.widen or decoderLicenseVuln.widen

    implicit val decoderTopLevelFilteredInfo  : Decoder[TopLevelFilteredInfo]  = deriveDecoder
    implicit val decoderSnykVulnResponse      : Decoder[SnykVulnResponse]      = deriveDecoder

    implicit val encoderVulnIgnoredBy         : ObjectEncoder[IgnoredBy]        = deriveEncoder
    implicit val encoderVulnIgnoredInfo       : ObjectEncoder[VulnIgnoredInfo]  = deriveEncoder
    implicit val encoderVulnFilteredInfo      : ObjectEncoder[VulnFilteredInfo] = deriveEncoder
    implicit val encoderLicensesPolicy        : ObjectEncoder[LicensesPolicy]   = deriveEncoder
    implicit val encoderMavenModuleName       : ObjectEncoder[MavenModuleName]  = deriveEncoder
    implicit val encoderSemver                : ObjectEncoder[Semver]           = deriveEncoder

    implicit val encoderSecurityVuln          : ObjectEncoder[SecurityVuln]     = deriveEncoder
    implicit val encoderLicenseVuln           : ObjectEncoder[LicenseVuln]      = deriveEncoder

    implicit val encoderVulnerability: ObjectEncoder[Vulnerability] = ObjectEncoder.instance {
      case sec: SecurityVuln => sec.asJsonObject
      case lic: LicenseVuln => lic.asJsonObject
    }

    implicit val encoderTopLevelFilteredInfo  : ObjectEncoder[TopLevelFilteredInfo]  = deriveEncoder
    implicit val encoderSnykVulnResponse      : ObjectEncoder[SnykVulnResponse]      = deriveEncoder
  }
}



